// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ProcessMesh
#pragma kernel Voxelize

typedef uint triangle_ptr;
typedef uint node_ptr;
#define nullptr 0
#define FLT_MAX 3.402823e+38
#define FLT_MIN 1.175494e-38

struct TreeNode
{
	float3 origin;
	float extends;
	triangle_ptr triangles[4];
	node_ptr children[8];
};

#include "Assets/Shaders/Intersection.compute"

RWStructuredBuffer<tripoly> triangles;
uint triangleCount;
float4x4 modelmatrix;
StructuredBuffer<int> indices;
RWStructuredBuffer<float3> vertices;
float time;
bool animate;

[numthreads(1024, 1, 1)]
void ProcessMesh(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID)
{
	if (id.x > triangleCount)
		return;

	uint triIdx = id.x * 3;
	tripoly tri;

	float3 v0 = vertices[indices[triIdx + 0]];
	float3 v1 = vertices[indices[triIdx + 1]];
	float3 v2 = vertices[indices[triIdx + 2]];

	if (animate)
	{
		v0 = v0 + (float3(sin(v0.x + time), sin(v0.y + time), sin(v0.z + time))*0.1f);
		v1 = v1 + (float3(sin(v1.x + time), sin(v1.y + time), sin(v1.z + time))*0.1f);
		v2 = v2 + (float3(sin(v2.x + time), sin(v2.y + time), sin(v2.z + time))*0.1f);
		tri.v[0] = v0;
		tri.v[1] = v1;
		tri.v[2] = v2;
		vertices[indices[triIdx + 0]] = v0;
		vertices[indices[triIdx + 1]] = v1;
		vertices[indices[triIdx + 2]] = v2;
	}
	else
	{
		tri.v[0] = mul(modelmatrix, float4(v0, 1)).xyz;
		tri.v[1] = mul(modelmatrix, float4(v1, 1)).xyz;
		tri.v[2] = mul(modelmatrix, float4(v2, 1)).xyz;
	}

	triangles[id.x] = tri;
}

RWStructuredBuffer<TreeNode> octree;
RWStructuredBuffer<uint> hierarchy;
uint resolution;
float voxelSize;

uint Idx3ToIdx(uint3 idx3, uint res)
{
	return idx3.x + (idx3.z * res) + (idx3.y * res * res);
}

uint3 IdxToIdx3(uint idx, uint res)
{
	return uint3(idx % res, idx / (res * res), (idx / res) % res);
}

[numthreads(1024, 1, 1)]
void Voxelize(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID)
{
	const uint idx = id.x;

	// Allows the shader to fast forward through everything without effecting anything else. Also allows the use of memory barriers.
	bool returned = false;

	if (idx >= (resolution * resolution * resolution)) // if the index is outside the bounds escape.
		returned = true;

	uint3 idx3 = IdxToIdx3(idx, resolution);
	float fullSize = resolution * voxelSize;
	float boundSize = voxelSize;
	float extends = boundSize * 0.5f;
	float3 origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);

	triangle_ptr triangleIndices[4];
	triangleIndices[0] = nullptr;
	triangleIndices[1] = nullptr;
	triangleIndices[2] = nullptr;
	triangleIndices[3] = nullptr;

	bool trianglesFound = false;
	uint lastIdx = 0;

	{// Get intersecting triangles.
		for (uint i = 0; i < triangleCount; i++)
		{
			if (t_c_intersection(triangles[i], origin, extends))
			{
				trianglesFound = true;
				triangleIndices[lastIdx] = i + 1;
				lastIdx++;
				if (lastIdx >= 4)
					break;
			}
		}
	}

	const uint maxGenerationCount = uint((log((float)triangleCount) / log(8.f)) * 3.f); // Technically it should be infinity but we don't want that, so we call it 3x the minimal generation count.

	uint nodesInGeneration = resolution * resolution * resolution;
	uint generationResolution = resolution;
	uint childrenResolution = resolution;
	uint totalNodes = 0;
	uint childTotal = 0;
	uint generationalIdx = idx;
	uint3 generationIdx3 = idx3;
	uint childIdx = 0;
	uint3 childIdx3;

	{
		for (uint generation = 0; generation < maxGenerationCount; generation++)
		{
			AllMemoryBarrierWithGroupSync();

			//									triangles													children
			TreeNode node = { origin, extends, { /*0*/nullptr, /*1*/nullptr, /*2*/nullptr, /*3*/nullptr }, { /*0*/nullptr, /*1*/nullptr, /*2*/nullptr, /*3*/nullptr, /*4*/nullptr, /*5*/nullptr, /*6*/nullptr, /*7*/nullptr } };

			if (!returned)
			{
				if (generation == 0) // Set triangles only for leaf nodes.
				{
					node.triangles[0] = triangleIndices[0];
					node.triangles[1] = triangleIndices[1];
					node.triangles[2] = triangleIndices[2];
					node.triangles[3] = triangleIndices[3];
				}
				else // Set children only for any branch generation.
				{
					childIdx3 = IdxToIdx3(childIdx, childrenResolution);
					node.children[0] = hierarchy[childTotal + Idx3ToIdx(childIdx3, childrenResolution)]; // 0, 0, 0
					node.children[1] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 0, 0), childrenResolution)]; // 1, 0, 0
					node.children[2] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 0, 1), childrenResolution)]; // 1, 0, 1
					node.children[3] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(0, 0, 1), childrenResolution)]; // 0, 0, 1
					node.children[4] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(0, 1, 0), childrenResolution)]; // 0, 1, 0
					node.children[5] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 1, 0), childrenResolution)]; // 1, 1, 0
					node.children[6] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 1, 1), childrenResolution)]; // 1, 1, 1
					node.children[7] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(0, 1, 1), childrenResolution)]; // 0, 1, 1
				}
			}

			// Filter out whether we are the 1st child of our parent or not.
			uint3 subIdx3;
			subIdx3.x = idx3.x % (uint) (floor(pow(2, generation)));
			subIdx3.y = idx3.y % (uint) (floor(pow(2, generation)));
			subIdx3.z = idx3.z % (uint) (floor(pow(2, generation)));
			if (subIdx3.x != 0 || subIdx3.y != 0 || subIdx3.z != 0)
			{
				returned = true;
			}

			uint3 parentIdx3 = floor(generationIdx3 / 2.f);

			if (!returned)
			{
				if (generation == 0)
				{
					if (trianglesFound)
					{
						uint indx = octree.IncrementCounter();
						octree[indx] = node;
						hierarchy[totalNodes + generationalIdx] = indx + 1;
					}
				}
				else
				{
					bool hasChildren = false;
					hasChildren = hasChildren || (node.children[0] != nullptr);
					hasChildren = hasChildren || (node.children[1] != nullptr);
					hasChildren = hasChildren || (node.children[2] != nullptr);
					hasChildren = hasChildren || (node.children[3] != nullptr);
					hasChildren = hasChildren || (node.children[4] != nullptr);
					hasChildren = hasChildren || (node.children[5] != nullptr);
					hasChildren = hasChildren || (node.children[6] != nullptr);
					hasChildren = hasChildren || (node.children[7] != nullptr);

					if (hasChildren)
					{
						uint indx = octree.IncrementCounter();
						octree[indx] = node;
						hierarchy[totalNodes + generationalIdx] = indx + 1;
					}
				}
			}

			if (extends * 2.f >= fullSize)
			{
				returned = true;
			}

			childIdx = generationalIdx;
			childTotal = totalNodes;
			totalNodes += nodesInGeneration;
			nodesInGeneration = nodesInGeneration / 8;
			childrenResolution = generationResolution;
			generationResolution = generationResolution / 2;
			generationalIdx = Idx3ToIdx(parentIdx3, generationResolution);
			childIdx3 = generationIdx3;
			generationIdx3 = parentIdx3;
			extends *= 2.f;
			origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);
		}
	}

	//GroupMemoryBarrierWithGroupSync();

	//nodesInGeneration = resolution * resolution * resolution;
	//generationResolution = resolution;
	//childrenResolution = resolution;
	//totalNodes = 0;
	//generationalIdx = idx;
	//generationIdx3 = idx3;
	//childIdx = 0;
	//childIdx3;
	//returned = false;

	//if (idx >= (resolution * resolution * resolution)) // if the index is outside the bounds escape.
	//	returned = true;

	//{
	//	for (uint generation = 0; generation < maxGenerationCount; generation++)
	//	{
	//		if (generation != 0)
	//		{
	//			TreeNode node = octree[hierarchy[totalNodes + generationalIdx] - 1];
	//			childIdx3 = IdxToIdx3(childIdx, childrenResolution);
	//			node.children[0] = hierarchy[childTotal + Idx3ToIdx(childIdx3, childrenResolution)]; // 0, 0, 0
	//			node.children[1] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 0, 0), childrenResolution)]; // 1, 0, 0
	//			node.children[2] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 0, 1), childrenResolution)]; // 1, 0, 1
	//			node.children[3] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(0, 0, 1), childrenResolution)]; // 0, 0, 1
	//			node.children[4] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(0, 1, 0), childrenResolution)]; // 0, 1, 0
	//			node.children[5] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 1, 0), childrenResolution)]; // 1, 1, 0
	//			node.children[6] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(1, 1, 1), childrenResolution)]; // 1, 1, 1
	//			node.children[7] = hierarchy[childTotal + Idx3ToIdx(childIdx3 + uint3(0, 1, 1), childrenResolution)]; // 0, 1, 1
	//			octree[hierarchy[totalNodes + generationalIdx] - 1] = node;
	//		}

	//		uint3 subIdx3;
	//		subIdx3.x = idx3.x % (uint) (floor(pow(2, generation)));
	//		subIdx3.y = idx3.y % (uint) (floor(pow(2, generation)));
	//		subIdx3.z = idx3.z % (uint) (floor(pow(2, generation)));
	//		if (subIdx3.x != 0 || subIdx3.y != 0 || subIdx3.z != 0)
	//		{
	//			returned = true;
	//		}

	//		uint3 parentIdx3 = floor(generationIdx3 / 2.f);

	//		if (!returned)
	//		{
	//			if (generation == 0)
	//			{
	//				
	//			}
	//			else
	//			{
	//				bool hasChildren = true;
	//				hasChildren = hasChildren || (node.children[0] != nullptr);
	//				hasChildren = hasChildren || (node.children[1] != nullptr);
	//				hasChildren = hasChildren || (node.children[2] != nullptr);
	//				hasChildren = hasChildren || (node.children[3] != nullptr);
	//				hasChildren = hasChildren || (node.children[4] != nullptr);
	//				hasChildren = hasChildren || (node.children[5] != nullptr);
	//				hasChildren = hasChildren || (node.children[6] != nullptr);
	//				hasChildren = hasChildren || (node.children[7] != nullptr);

	//				if (hasChildren)
	//				{
	//					uint indx = octree.IncrementCounter();
	//					octree[indx] = node;
	//					hierarchy[totalNodes + generationalIdx] = indx + 1;
	//				}
	//			}
	//		}

	//		if (extends * 2.f >= fullSize)
	//		{
	//			returned = true;
	//		}

	//		childIdx = generationalIdx;
	//		totalNodes += nodesInGeneration;
	//		nodesInGeneration /= 8;
	//		childrenResolution = generationResolution;
	//		generationResolution /= 2;
	//		generationalIdx = totalNodes;
	//		childIdx3 = generationIdx3;
	//		generationIdx3 = parentIdx3;
	//		extends *= 2.f;
	//		origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);
	//	}
	//}
}
