// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

typedef uint triangle_ptr;
typedef uint node_ptr;
#define nullptr 0
#define FLT_MAX 3.402823e+38
#define FLT_MIN 1.175494e-38

struct TreeNode
{
    float3 origin;
    float extends;
    triangle_ptr triangles[4];
    node_ptr children[8];
};

#include "Assets/Shaders/Intersection.compute"

RWStructuredBuffer<TreeNode> octree;
RWStructuredBuffer<uint> hierarchy;
StructuredBuffer<uint> triangleIndeces;
StructuredBuffer<tripoly> triangles;
uint resolution;
float voxelSize;
uint triangleCount;

// intersection between a point and an axis aligned bounding cube at the origin (extends is half the width/height/depth).
bool PointOAABC(float3 p, float extends)
{
    return !((p.x < -extends || p.x > extends) || (p.y < -extends || p.y > extends) || (p.z < -extends || p.z > extends));
}

void ProjectTriangle(tripoly tri, float3 axis, out float minVal, out float maxVal)
{
    minVal = FLT_MIN;
    maxVal = FLT_MAX;
    for (uint i = 0; i < 3; i++)
    {
        float val = dot(axis, tri.v[i]);
        minVal = min(minVal, val);
        maxVal = max(maxVal, val);
    }
}

void ProjectBox(float extends, float3 axis, out float minVal, out float maxVal)
{
    float3 vertices[8];
    vertices[0] = float3(-extends, -extends, -extends);
    vertices[1] = float3(extends, -extends, -extends);
    vertices[2] = float3(extends, -extends, extends);
    vertices[3] = float3(-extends, -extends, extends);
    vertices[4] = float3(-extends, extends, -extends);
    vertices[5] = float3(extends, extends, -extends);
    vertices[6] = float3(extends, extends, extends);
    vertices[7] = float3(-extends, extends, extends);


    minVal = FLT_MAX;
    maxVal = FLT_MIN;

    for (uint i = 0; i < 8; i++)
    {
        float val = dot(axis, vertices[i]);
        minVal = min(minVal, val);
        maxVal = max(maxVal, val);
    }
}

bool TriangleAABB(tripoly tri, float3 origin, float extends)
{
	{
        for (int i = 0; i < 3; i++)
        {
            tri.v[i] -= origin;
            if (PointOAABC(tri.v[i], extends))
                return true;
        }
    }


    float3 triangleEdges[3];
    triangleEdges[0] = tri.v[1] - tri.v[0];
    triangleEdges[1] = tri.v[2] - tri.v[1];
    triangleEdges[2] = tri.v[0] - tri.v[2];

    float3 boxNormals[3];
    boxNormals[0] = float3(1, 0, 0);
    boxNormals[0] = float3(0, 1, 0);
    boxNormals[0] = float3(0, 0, 1);

    float triangleMin, triangleMax;
    float boxMin, boxMax;

	{
        for (int i = 0; i < 3; i++)
        {
            ProjectTriangle(tri, boxNormals[i], triangleMin, triangleMax);
            if (triangleMax < -extends || triangleMin > extends)
                return false;
        }
    }

    float3 triangleNormal = normalize(cross(tri.v[0], tri.v[1]));
    float triangleOffset = dot(triangleNormal, tri.v[0]);
    ProjectBox(extends, triangleNormal, boxMin, boxMax);
    if (boxMax < triangleOffset || boxMin > triangleOffset)
        return false;

	{
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
            {
                float3 axis = cross(triangleEdges[i], boxNormals[j]);
                if (length(axis) == 0)
                    continue;

                axis = normalize(axis);

                ProjectBox(extends, axis, boxMin, boxMax);
                ProjectTriangle(tri, axis, triangleMin, triangleMax);
                if (boxMax < triangleMin || boxMin > triangleMax)
                    return false;
            }
    }

    return true;
}

uint Idx3ToIdx(uint3 idx3, uint res)
{
    return idx3.x + (idx3.z * res) + (idx3.y * res * res);
}

uint3 IdxToIdx3(uint idx, uint res)
{
    return uint3(idx % res, idx / (res * res), (idx / res) % res);
}

[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID)
{
    uint idx = id.x + (1024 * groupId.x);

    if (idx >= (resolution * resolution * resolution))
        return;

    uint3 idx3 = IdxToIdx3(idx, resolution);
    float fullSize = resolution * voxelSize;
    float boundSize = voxelSize;
    float extends = boundSize * 0.5f;
    float3 origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);

    triangle_ptr triangleIndices[4];
    triangleIndices[0] = nullptr;
    triangleIndices[1] = nullptr;
    triangleIndices[2] = nullptr;
    triangleIndices[3] = nullptr;

    bool trianglesFound = false;
    uint lastIdx = 0;
	{
        for (uint i = 0; i < triangleCount; i++)
        {
            if (t_c_intersection(triangles[i], origin, extends))
            {
                trianglesFound = true;
                triangleIndices[lastIdx] = i + 1;
                lastIdx++;
                if (lastIdx >= 4)
                    break;
            }
        }
    }

    uint maxGenerationCount = uint((log((float) triangleCount) / log(8.f)) * 3.f); // Technically it should be infinity but we don't want that, so we call it 3x the minimal generation count.

    uint nodesInGeneration = resolution * resolution * resolution;
    uint generationResolution = resolution;
    uint totalNodes = 0;
    uint generationalIdx = idx;
    uint3 generationIdx3 = idx3;
    uint childIdx = 0;
    uint3 childIdx3;

    for (uint generation = 0; generation < maxGenerationCount; generation++)
    {
        TreeNode node;
        node.origin = origin;
        node.extends = extends;

        if (generation == 0)
        {
            for (int i = 0; i < 4; i++)
                node.triangles[i] = triangleIndices[i];
        }
        else
        {
            for (int i = 0; i < 4; i++)
                node.triangles[i] = nullptr;
        }

        if (generation == 0)
        {
            for (int i = 0; i < 4; i++)
                node.children[i] = nullptr;
        }
        else
        {
            node.children[0] = hierarchy[childIdx]; // 0, 0, 0
            node.children[1] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 0, 0), generationResolution)]; // 1, 0, 0
            node.children[2] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 0, 1), generationResolution)]; // 1, 0, 1
            node.children[3] = hierarchy[Idx3ToIdx(childIdx3 + uint3(0, 0, 1), generationResolution)]; // 0, 0, 1
            node.children[4] = hierarchy[Idx3ToIdx(childIdx3 + uint3(0, 1, 0), generationResolution)]; // 0, 1, 0
            node.children[5] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 1, 0), generationResolution)]; // 1, 1, 0
            node.children[6] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 1, 1), generationResolution)]; // 1, 1, 1
            node.children[7] = hierarchy[Idx3ToIdx(childIdx3 + uint3(0, 1, 1), generationResolution)]; // 0, 1, 1
        }

        uint3 subIdx3;
        subIdx3.x = idx3.x % (uint) (floor(pow(2, generation)));
        subIdx3.y = idx3.y % (uint) (floor(pow(2, generation)));
        subIdx3.z = idx3.z % (uint) (floor(pow(2, generation)));
        if (subIdx3.x != 0 || subIdx3.y != 0 || subIdx3.z != 0)
        {
            return;
        }

        uint3 parentIdx3 = floor(generationIdx3 / 2.f);

        if (generation == 0)
        {
            if (trianglesFound)
            {
                uint indx = octree.IncrementCounter();
                octree[indx] = node;
                hierarchy[generationalIdx] = indx + 1;
            }
        }
        else
        {
            uint indx = octree.IncrementCounter();
            octree[indx] = node;
            hierarchy[generationalIdx] = indx + 1;
        }

        if (extends * 2.f >= fullSize)
            return;

        childIdx = generationalIdx;
        totalNodes += nodesInGeneration;
        nodesInGeneration /= 8;
        generationResolution /= 2;
        generationalIdx = totalNodes;
        childIdx3 = generationIdx3;
        generationIdx3 = parentIdx3;
        extends *= 2.f;
        origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);
    }
}
