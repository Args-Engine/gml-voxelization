// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

typedef uint triangle_ptr;
typedef uint node_ptr;
#define nullptr 0
#define FLT_MAX 3.402823e+38
#define FLT_MIN 1.175494e-38

struct TreeNode
{
	float3 origin;
	float extends;
	triangle_ptr triangles[4];
	node_ptr children[8];
};

#include "Assets/Shaders/Intersection.compute"

RWStructuredBuffer<TreeNode> octree;
RWStructuredBuffer<uint> hierarchy;
StructuredBuffer<uint> triangleIndeces;
StructuredBuffer<tripoly> triangles;
uint resolution;
float voxelSize;
uint triangleCount;

uint Idx3ToIdx(uint3 idx3, uint res)
{
	return idx3.x + (idx3.z * res) + (idx3.y * res * res);
}

uint3 IdxToIdx3(uint idx, uint res)
{
	return uint3(idx % res, idx / (res * res), (idx / res) % res);
}

[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID)
{
	const uint idx = id.x;

	if (idx >= (resolution * resolution * resolution))
		return;

	uint3 idx3 = IdxToIdx3(idx, resolution);
	float fullSize = resolution * voxelSize;
	float boundSize = voxelSize;
	float extends = boundSize * 0.5f;
	float3 origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);

	triangle_ptr triangleIndices[4];
	triangleIndices[0] = nullptr;
	triangleIndices[1] = nullptr;
	triangleIndices[2] = nullptr;
	triangleIndices[3] = nullptr;

	bool trianglesFound = false;
	uint lastIdx = 0;
	{
		for (uint i = 0; i < triangleCount; i++)
		{
			if (t_c_intersection(triangles[i], origin, extends))
			{
				trianglesFound = true;
				triangleIndices[lastIdx] = i + 1;
				lastIdx++;
				if (lastIdx >= 4)
					break;
			}
		}
	}

	const uint maxGenerationCount = uint((log((float)triangleCount) / log(8.f)) * 3.f); // Technically it should be infinity but we don't want that, so we call it 3x the minimal generation count.

	uint nodesInGeneration = resolution * resolution * resolution;
	uint generationResolution = resolution;
	uint childrenResolution = resolution;
	uint totalNodes = 0;
	uint childTotal = 0;
	uint generationalIdx = idx;
	uint3 generationIdx3 = idx3;
	uint childIdx = 0;
	uint3 childIdx3;

	{
		for (uint generation = 0; generation < maxGenerationCount; generation++)
		{
			TreeNode node = { origin, extends, { /*0*/nullptr, /*1*/nullptr, /*2*/nullptr, /*3*/nullptr }, { /*0*/nullptr, /*1*/nullptr, /*2*/nullptr, /*3*/nullptr, /*4*/nullptr, /*5*/nullptr, /*6*/nullptr, /*7*/nullptr } };

			if (generation == 0)
			{
				node.triangles[0] = triangleIndices[0];
				node.triangles[1] = triangleIndices[1];
				node.triangles[2] = triangleIndices[2];
				node.triangles[3] = triangleIndices[3];
			}
			else
			{
				childIdx3 = IdxToIdx3(childIdx, childrenResolution);
				node.children[0] = childTotal + Idx3ToIdx(childIdx3, childrenResolution) + 1; // 0, 0, 0
				node.children[1] = childTotal + Idx3ToIdx(childIdx3 + uint3(1, 0, 0), childrenResolution) + 1; // 1, 0, 0
				node.children[2] = childTotal + Idx3ToIdx(childIdx3 + uint3(1, 0, 1), childrenResolution) + 1; // 1, 0, 1
				node.children[3] = childTotal + Idx3ToIdx(childIdx3 + uint3(0, 0, 1), childrenResolution) + 1; // 0, 0, 1
				node.children[4] = childTotal + Idx3ToIdx(childIdx3 + uint3(0, 1, 0), childrenResolution) + 1; // 0, 1, 0
				node.children[5] = childTotal + Idx3ToIdx(childIdx3 + uint3(1, 1, 0), childrenResolution) + 1; // 1, 1, 0
				node.children[6] = childTotal + Idx3ToIdx(childIdx3 + uint3(1, 1, 1), childrenResolution) + 1; // 1, 1, 1
				node.children[7] = childTotal + Idx3ToIdx(childIdx3 + uint3(0, 1, 1), childrenResolution) + 1; // 0, 1, 1
			}

			uint3 subIdx3;
			subIdx3.x = idx3.x % (uint) (floor(pow(2, generation)));
			subIdx3.y = idx3.y % (uint) (floor(pow(2, generation)));
			subIdx3.z = idx3.z % (uint) (floor(pow(2, generation)));
			if (subIdx3.x != 0 || subIdx3.y != 0 || subIdx3.z != 0)
			{
				return;
			}

			uint3 parentIdx3 = floor(generationIdx3 / 2.f);

			if (generation == 0)
			{
				if (trianglesFound)
				{
					uint indx = octree.IncrementCounter();
					octree[indx] = node;
					hierarchy[totalNodes + generationalIdx] = indx + 1;
				}
			}
			else
			{
				uint indx = octree.IncrementCounter();
				octree[indx] = node;
				hierarchy[totalNodes + generationalIdx] = indx + 1;
			}

			if (extends * 2.f >= fullSize)
				return;

			childIdx = generationalIdx;
			childTotal = totalNodes;
			totalNodes += nodesInGeneration;
			nodesInGeneration = nodesInGeneration / 8;
			childrenResolution = generationResolution;
			generationResolution = generationResolution / 2;
			generationalIdx = Idx3ToIdx(parentIdx3, generationResolution);
			childIdx3 = generationIdx3;
			generationIdx3 = parentIdx3;
			extends *= 2.f;
			origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);
		}
	}

	//GroupMemoryBarrierWithGroupSync();

	//nodesInGeneration = resolution * resolution * resolution;
	//generationResolution = resolution;
	//childrenResolution = resolution;
	//totalNodes = 0;
	//generationalIdx = idx;
	//generationIdx3 = idx3;
	//childIdx = 0;
	//childIdx3;

	//{
	//	for (uint generation = 0; generation < maxGenerationCount; generation++)
	//	{
	//		if (generation != 0)
	//		{
	//			TreeNode node = octree[hierarchy[generationalIdx] - 1];
	//			node.children[0] = hierarchy[childIdx]; // 0, 0, 0
	//			node.children[1] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 0, 0), childrenResolution)]; // 1, 0, 0
	//			node.children[2] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 0, 1), childrenResolution)]; // 1, 0, 1
	//			node.children[3] = hierarchy[Idx3ToIdx(childIdx3 + uint3(0, 0, 1), childrenResolution)]; // 0, 0, 1
	//			node.children[4] = hierarchy[Idx3ToIdx(childIdx3 + uint3(0, 1, 0), childrenResolution)]; // 0, 1, 0
	//			node.children[5] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 1, 0), childrenResolution)]; // 1, 1, 0
	//			node.children[6] = hierarchy[Idx3ToIdx(childIdx3 + uint3(1, 1, 1), childrenResolution)]; // 1, 1, 1
	//			node.children[7] = hierarchy[Idx3ToIdx(childIdx3 + uint3(0, 1, 1), childrenResolution)]; // 0, 1, 1
	//			octree[hierarchy[generationalIdx] - 1] = node;
	//		}

	//		uint3 subIdx3;
	//		subIdx3.x = idx3.x % (uint) (floor(pow(2, generation)));
	//		subIdx3.y = idx3.y % (uint) (floor(pow(2, generation)));
	//		subIdx3.z = idx3.z % (uint) (floor(pow(2, generation)));
	//		if (subIdx3.x != 0 || subIdx3.y != 0 || subIdx3.z != 0)
	//		{
	//			break;
	//		}

	//		uint3 parentIdx3 = floor(generationIdx3 / 2.f);

	//		if (extends * 2.f >= fullSize)
	//			break;

	//		childIdx = generationalIdx;
	//		totalNodes += nodesInGeneration;
	//		nodesInGeneration /= 8;
	//		childrenResolution = generationResolution;
	//		generationResolution /= 2;
	//		generationalIdx = totalNodes;
	//		childIdx3 = generationIdx3;
	//		generationIdx3 = parentIdx3;
	//		extends *= 2.f;
	//		origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);
	//	}
	//}
}
