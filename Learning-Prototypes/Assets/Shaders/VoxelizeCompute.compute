// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

typedef uint triangle_ptr;
typedef uint node_ptr;
#define nullptr 0
#define FLT_MAX 3.402823e+38
#define FLT_MIN 1.175494e-38

struct TreeNode
{
	float3 origin;
	float extends;
	triangle_ptr triangles[4];
	node_ptr children[8];
};

#include "Assets/Shaders/Intersection.compute"

RWStructuredBuffer<TreeNode> octree;
RWStructuredBuffer<uint> hierarchy;
StructuredBuffer<uint> triangleIndeces;
StructuredBuffer<tripoly> triangles;
uint resolution;
float voxelSize;
uint triangleCount;

// intersection between a point and an axis aligned bounding cube at the origin (extends is half the width/height/depth).
bool PointOAABC(float3 p, float extends)
{
	return !((p.x < -extends || p.x > extends) || (p.y < -extends || p.y > extends) || (p.z < -extends || p.z > extends));
}

void ProjectTriangle(tripoly tri, float3 axis, out float minVal, out float maxVal)
{
	minVal = FLT_MIN;
	maxVal = FLT_MAX;
	for (uint i = 0; i < 3; i++)
	{
		float val = dot(axis, tri.v[i]);
		minVal = min(minVal, val);
		maxVal = max(maxVal, val);
	}
}

void ProjectBox(float extends, float3 axis, out float minVal, out float maxVal)
{
	float3 vertices[8];
	vertices[0] = float3(-extends, -extends, -extends);
	vertices[1] = float3(extends, -extends, -extends);
	vertices[2] = float3(extends, -extends, extends);
	vertices[3] = float3(-extends, -extends, extends);
	vertices[4] = float3(-extends, extends, -extends);
	vertices[5] = float3(extends, extends, -extends);
	vertices[6] = float3(extends, extends, extends);
	vertices[7] = float3(-extends, extends, extends);


	minVal = FLT_MAX;
	maxVal = FLT_MIN;

	for (uint i = 0; i < 8; i++)
	{
		float val = dot(axis, vertices[i]);
		minVal = min(minVal, val);
		maxVal = max(maxVal, val);
	}
}

bool TriangleAABB(tripoly tri, float3 origin, float extends)
{
	{
		for (int i = 0; i < 3; i++)
		{
			tri.v[i] -= origin;
			if (PointOAABC(tri.v[i], extends))
				return true;
		}
	}


	float3 triangleEdges[3];
	triangleEdges[0] = tri.v[1] - tri.v[0];
	triangleEdges[1] = tri.v[2] - tri.v[1];
	triangleEdges[2] = tri.v[0] - tri.v[2];

	float3 boxNormals[3];
	boxNormals[0] = float3(1, 0, 0);
	boxNormals[0] = float3(0, 1, 0);
	boxNormals[0] = float3(0, 0, 1);

	float triangleMin, triangleMax;
	float boxMin, boxMax;

	{
		for (int i = 0; i < 3; i++)
		{
			ProjectTriangle(tri, boxNormals[i], triangleMin, triangleMax);
			if (triangleMax < -extends || triangleMin > extends)
				return false;
		}
	}

	float3 triangleNormal = normalize(cross(tri.v[0], tri.v[1]));
	float triangleOffset = dot(triangleNormal, tri.v[0]);
	ProjectBox(extends, triangleNormal, boxMin, boxMax);
	if (boxMax < triangleOffset || boxMin > triangleOffset)
		return false;

	{
		for (int i = 0; i < 3; i++)
			for (int j = 0; j < 3; j++)
			{
				float3 axis = cross(triangleEdges[i], boxNormals[j]);
				if (length(axis) == 0)
					continue;

				axis = normalize(axis);

				ProjectBox(extends, axis, boxMin, boxMax);
				ProjectTriangle(tri, axis, triangleMin, triangleMax);
				if (boxMax < triangleMin || boxMin > triangleMax)
					return false;
			}
	}

	return true;
}

[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID)
{
	uint idx = id.x + (1024 * groupId.x);

	if (idx >= (resolution * resolution * resolution))
		return;

	uint3 idx3 = uint3(idx % resolution, idx / (resolution * resolution), (idx / resolution) % resolution);

	float fullSize = resolution * voxelSize;
	float boundSize = voxelSize;
	float extends = boundSize * 0.5f;
	float3 origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);

	triangle_ptr triangleIndices[4];
	triangleIndices[0] = nullptr;
	triangleIndices[1] = nullptr;
	triangleIndices[2] = nullptr;
	triangleIndices[3] = nullptr;

	bool trianglesFound = false;
	uint lastIdx = 0;
	{
		for (uint i = 0; i < triangleCount; i++)
		{
			if (t_c_intersection(triangles[i], origin, extends))
			{
				trianglesFound = true;
				triangleIndices[lastIdx] = i + 1;
				lastIdx++;
				if (lastIdx >= 4)
					break;
			}
		}
	}

	uint maxGenerationCount = uint((log((float)triangleCount) / log(8.f)) * 3.f); // Technically it should be infinity but we don't want that, so we call it 3x the minimal generation count.

	uint nodesInGeneration = resolution * resolution * resolution;
	uint totalNodes = 0;
	uint generationalIdx = idx;
	uint childIdx = 0;

	for (uint generation = 0; generation < maxGenerationCount; generation++)
	{
		TreeNode node;
		node.origin = origin;
		node.extends = extends;

		if (generation == 0)
		{
			for (int i = 0; i < 4; i++)
				node.triangles[i] = triangleIndices[i];
		}
		else
		{
			for (int i = 0; i < 4; i++)
				node.triangles[i] = nullptr;
		}

		if (generation == 0)
		{
			for (int i = 0; i < 4; i++)
				node.children[i] = nullptr;
		}
		{
			for (int i = 0; i < 8; i++)
				node.children[i] = hierarchy[childIdx + i];
		}

		uint3 subIdx3;
		subIdx3.x = idx3.x % (uint)(floor(pow(2, generation)));
		subIdx3.y = idx3.y % (uint)(floor(pow(2, generation)));
		subIdx3.z = idx3.z % (uint)(floor(pow(2, generation)));
		if (subIdx3.x != 0 || subIdx3.y != 0 || subIdx3.z != 0)
		{
			return;
		}

		uint subIdx = subIdx3.x + (subIdx3.z * 2) + (subIdx3.y * 4);
		uint parentIdx = round((generationalIdx - totalNodes) / 8.f);

		if (generation == 0)
		{
			if (trianglesFound)
			{
				uint indx = octree.IncrementCounter();
				octree[indx] = node;
				hierarchy[generationalIdx] = indx + 1;
			}
		}
		else
		{
			uint indx = octree.IncrementCounter();
			octree[indx] = node;
			hierarchy[generationalIdx] = indx + 1;
		}

		if (extends * 2.f >= fullSize)
			return;

		childIdx = generationalIdx;
		totalNodes += nodesInGeneration;
		nodesInGeneration /= 8;
		generationalIdx = totalNodes + parentIdx;
		extends *= 2.f;
		origin = (float3(idx3.x, idx3.y, idx3.z) * float3(boundSize, boundSize, boundSize)) + float3(extends, extends, extends) - (fullSize * 0.5f);
	}
}
